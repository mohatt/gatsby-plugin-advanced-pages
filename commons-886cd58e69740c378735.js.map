{"version":3,"file":"commons-886cd58e69740c378735.js","mappings":"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","sources":["webpack://gatsby-advanced-pages-example/./src/components/layout.js","webpack://gatsby-advanced-pages-example/../src/index.ts","webpack://gatsby-advanced-pages-example/./node_modules/gatsby-plugin-advanced-pages/dist/route-compiler-DlYb6nBY.js","webpack://gatsby-advanced-pages-example/./node_modules/clsx/dist/clsx.mjs","webpack://gatsby-advanced-pages-example/./node_modules/gatsby-plugin-advanced-pages/dist/index.js","webpack://gatsby-advanced-pages-example/./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js"],"sourcesContent":["import React from 'react'\nimport { Link } from 'gatsby-plugin-advanced-pages'\nimport './layout.css'\n\nconst menu = [\n  { title: 'Home', route: 'home' },\n  { title: 'Blog', route: 'blog' },\n  { title: 'About', route: 'about' },\n]\n\nconst Layout = ({ title, children }) => (\n  <div className='container'>\n    <header className='py-3'>\n      <nav className='navbar navbar-expand navbar-dark bg-dark rounded'>\n        <Link className='navbar-brand' to='home'>\n          Gatsby\n        </Link>\n        <ul className='navbar-nav'>\n          {menu.map((link) => (\n            <li key={link.title} className='nav-item'>\n              <Link\n                activeClassName='active'\n                className='nav-link'\n                to={link.route}\n                partiallyActive={link.route !== 'home'}\n              >\n                {link.title}\n              </Link>\n            </li>\n          ))}\n        </ul>\n      </nav>\n    </header>\n    <main className='p-5 bg-light'>\n      <div className='mb-4 pb-2 border-bottom'>\n        <h1>{title}</h1>\n      </div>\n      <content>{children}</content>\n    </main>\n    <footer className='text-muted my-5'>\n      © {new Date().getFullYear()},{` Built with `}\n      <a href='https://www.gatsbyjs.org'>Gatsby</a>\n      {` and `}\n      <a href='https://github.com/mohatt/gatsby-plugin-advanced-pages'>Gatsby Advanced Pages</a>\n    </footer>\n  </div>\n)\n\nexport default Layout\n","/**\n * Tokenizer results.\n */\ninterface LexToken {\n  type:\n    | \"OPEN\"\n    | \"CLOSE\"\n    | \"PATTERN\"\n    | \"NAME\"\n    | \"CHAR\"\n    | \"ESCAPED_CHAR\"\n    | \"MODIFIER\"\n    | \"END\";\n  index: number;\n  value: string;\n}\n\n/**\n * Tokenize input string.\n */\nfunction lexer(str: string): LexToken[] {\n  const tokens: LexToken[] = [];\n  let i = 0;\n\n  while (i < str.length) {\n    const char = str[i];\n\n    if (char === \"*\" || char === \"+\" || char === \"?\") {\n      tokens.push({ type: \"MODIFIER\", index: i, value: str[i++] });\n      continue;\n    }\n\n    if (char === \"\\\\\") {\n      tokens.push({ type: \"ESCAPED_CHAR\", index: i++, value: str[i++] });\n      continue;\n    }\n\n    if (char === \"{\") {\n      tokens.push({ type: \"OPEN\", index: i, value: str[i++] });\n      continue;\n    }\n\n    if (char === \"}\") {\n      tokens.push({ type: \"CLOSE\", index: i, value: str[i++] });\n      continue;\n    }\n\n    if (char === \":\") {\n      let name = \"\";\n      let j = i + 1;\n\n      while (j < str.length) {\n        const code = str.charCodeAt(j);\n\n        if (\n          // `0-9`\n          (code >= 48 && code <= 57) ||\n          // `A-Z`\n          (code >= 65 && code <= 90) ||\n          // `a-z`\n          (code >= 97 && code <= 122) ||\n          // `_`\n          code === 95\n        ) {\n          name += str[j++];\n          continue;\n        }\n\n        break;\n      }\n\n      if (!name) throw new TypeError(`Missing parameter name at ${i}`);\n\n      tokens.push({ type: \"NAME\", index: i, value: name });\n      i = j;\n      continue;\n    }\n\n    if (char === \"(\") {\n      let count = 1;\n      let pattern = \"\";\n      let j = i + 1;\n\n      if (str[j] === \"?\") {\n        throw new TypeError(`Pattern cannot start with \"?\" at ${j}`);\n      }\n\n      while (j < str.length) {\n        if (str[j] === \"\\\\\") {\n          pattern += str[j++] + str[j++];\n          continue;\n        }\n\n        if (str[j] === \")\") {\n          count--;\n          if (count === 0) {\n            j++;\n            break;\n          }\n        } else if (str[j] === \"(\") {\n          count++;\n          if (str[j + 1] !== \"?\") {\n            throw new TypeError(`Capturing groups are not allowed at ${j}`);\n          }\n        }\n\n        pattern += str[j++];\n      }\n\n      if (count) throw new TypeError(`Unbalanced pattern at ${i}`);\n      if (!pattern) throw new TypeError(`Missing pattern at ${i}`);\n\n      tokens.push({ type: \"PATTERN\", index: i, value: pattern });\n      i = j;\n      continue;\n    }\n\n    tokens.push({ type: \"CHAR\", index: i, value: str[i++] });\n  }\n\n  tokens.push({ type: \"END\", index: i, value: \"\" });\n\n  return tokens;\n}\n\nexport interface ParseOptions {\n  /**\n   * Set the default delimiter for repeat parameters. (default: `'/'`)\n   */\n  delimiter?: string;\n  /**\n   * List of characters to automatically consider prefixes when parsing.\n   */\n  prefixes?: string;\n}\n\n/**\n * Parse a string for the raw tokens.\n */\nexport function parse(str: string, options: ParseOptions = {}): Token[] {\n  const tokens = lexer(str);\n  const { prefixes = \"./\", delimiter = \"/#?\" } = options;\n  const result: Token[] = [];\n  let key = 0;\n  let i = 0;\n  let path = \"\";\n\n  const tryConsume = (type: LexToken[\"type\"]): string | undefined => {\n    if (i < tokens.length && tokens[i].type === type) return tokens[i++].value;\n  };\n\n  const mustConsume = (type: LexToken[\"type\"]): string => {\n    const value = tryConsume(type);\n    if (value !== undefined) return value;\n    const { type: nextType, index } = tokens[i];\n    throw new TypeError(`Unexpected ${nextType} at ${index}, expected ${type}`);\n  };\n\n  const consumeText = (): string => {\n    let result = \"\";\n    let value: string | undefined;\n    while ((value = tryConsume(\"CHAR\") || tryConsume(\"ESCAPED_CHAR\"))) {\n      result += value;\n    }\n    return result;\n  };\n\n  const isSafe = (value: string): boolean => {\n    for (const char of delimiter) if (value.indexOf(char) > -1) return true;\n    return false;\n  };\n\n  const safePattern = (prefix: string) => {\n    const prev = result[result.length - 1];\n    const prevText = prefix || (prev && typeof prev === \"string\" ? prev : \"\");\n\n    if (prev && !prevText) {\n      throw new TypeError(\n        `Must have text between two parameters, missing text after \"${(prev as Key).name}\"`,\n      );\n    }\n\n    if (!prevText || isSafe(prevText)) return `[^${escapeString(delimiter)}]+?`;\n    return `(?:(?!${escapeString(prevText)})[^${escapeString(delimiter)}])+?`;\n  };\n\n  while (i < tokens.length) {\n    const char = tryConsume(\"CHAR\");\n    const name = tryConsume(\"NAME\");\n    const pattern = tryConsume(\"PATTERN\");\n\n    if (name || pattern) {\n      let prefix = char || \"\";\n\n      if (prefixes.indexOf(prefix) === -1) {\n        path += prefix;\n        prefix = \"\";\n      }\n\n      if (path) {\n        result.push(path);\n        path = \"\";\n      }\n\n      result.push({\n        name: name || key++,\n        prefix,\n        suffix: \"\",\n        pattern: pattern || safePattern(prefix),\n        modifier: tryConsume(\"MODIFIER\") || \"\",\n      });\n      continue;\n    }\n\n    const value = char || tryConsume(\"ESCAPED_CHAR\");\n    if (value) {\n      path += value;\n      continue;\n    }\n\n    if (path) {\n      result.push(path);\n      path = \"\";\n    }\n\n    const open = tryConsume(\"OPEN\");\n    if (open) {\n      const prefix = consumeText();\n      const name = tryConsume(\"NAME\") || \"\";\n      const pattern = tryConsume(\"PATTERN\") || \"\";\n      const suffix = consumeText();\n\n      mustConsume(\"CLOSE\");\n\n      result.push({\n        name: name || (pattern ? key++ : \"\"),\n        pattern: name && !pattern ? safePattern(prefix) : pattern,\n        prefix,\n        suffix,\n        modifier: tryConsume(\"MODIFIER\") || \"\",\n      });\n      continue;\n    }\n\n    mustConsume(\"END\");\n  }\n\n  return result;\n}\n\nexport interface TokensToFunctionOptions {\n  /**\n   * When `true` the regexp will be case sensitive. (default: `false`)\n   */\n  sensitive?: boolean;\n  /**\n   * Function for encoding input strings for output.\n   */\n  encode?: (value: string, token: Key) => string;\n  /**\n   * When `false` the function can produce an invalid (unmatched) path. (default: `true`)\n   */\n  validate?: boolean;\n}\n\n/**\n * Compile a string to a template function for the path.\n */\nexport function compile<P extends object = object>(\n  str: string,\n  options?: ParseOptions & TokensToFunctionOptions,\n) {\n  return tokensToFunction<P>(parse(str, options), options);\n}\n\nexport type PathFunction<P extends object = object> = (data?: P) => string;\n\n/**\n * Expose a method for transforming tokens into the path function.\n */\nexport function tokensToFunction<P extends object = object>(\n  tokens: Token[],\n  options: TokensToFunctionOptions = {},\n): PathFunction<P> {\n  const reFlags = flags(options);\n  const { encode = (x: string) => x, validate = true } = options;\n\n  // Compile all the tokens into regexps.\n  const matches = tokens.map((token) => {\n    if (typeof token === \"object\") {\n      return new RegExp(`^(?:${token.pattern})$`, reFlags);\n    }\n  });\n\n  return (data: Record<string, any> | null | undefined) => {\n    let path = \"\";\n\n    for (let i = 0; i < tokens.length; i++) {\n      const token = tokens[i];\n\n      if (typeof token === \"string\") {\n        path += token;\n        continue;\n      }\n\n      const value = data ? data[token.name] : undefined;\n      const optional = token.modifier === \"?\" || token.modifier === \"*\";\n      const repeat = token.modifier === \"*\" || token.modifier === \"+\";\n\n      if (Array.isArray(value)) {\n        if (!repeat) {\n          throw new TypeError(\n            `Expected \"${token.name}\" to not repeat, but got an array`,\n          );\n        }\n\n        if (value.length === 0) {\n          if (optional) continue;\n\n          throw new TypeError(`Expected \"${token.name}\" to not be empty`);\n        }\n\n        for (let j = 0; j < value.length; j++) {\n          const segment = encode(value[j], token);\n\n          if (validate && !(matches[i] as RegExp).test(segment)) {\n            throw new TypeError(\n              `Expected all \"${token.name}\" to match \"${token.pattern}\", but got \"${segment}\"`,\n            );\n          }\n\n          path += token.prefix + segment + token.suffix;\n        }\n\n        continue;\n      }\n\n      if (typeof value === \"string\" || typeof value === \"number\") {\n        const segment = encode(String(value), token);\n\n        if (validate && !(matches[i] as RegExp).test(segment)) {\n          throw new TypeError(\n            `Expected \"${token.name}\" to match \"${token.pattern}\", but got \"${segment}\"`,\n          );\n        }\n\n        path += token.prefix + segment + token.suffix;\n        continue;\n      }\n\n      if (optional) continue;\n\n      const typeOfMessage = repeat ? \"an array\" : \"a string\";\n      throw new TypeError(`Expected \"${token.name}\" to be ${typeOfMessage}`);\n    }\n\n    return path;\n  };\n}\n\nexport interface RegexpToFunctionOptions {\n  /**\n   * Function for decoding strings for params.\n   */\n  decode?: (value: string, token: Key) => string;\n}\n\n/**\n * A match result contains data about the path match.\n */\nexport interface MatchResult<P extends object = object> {\n  path: string;\n  index: number;\n  params: P;\n}\n\n/**\n * A match is either `false` (no match) or a match result.\n */\nexport type Match<P extends object = object> = false | MatchResult<P>;\n\n/**\n * The match function takes a string and returns whether it matched the path.\n */\nexport type MatchFunction<P extends object = object> = (\n  path: string,\n) => Match<P>;\n\n/**\n * Create path match function from `path-to-regexp` spec.\n */\nexport function match<P extends object = object>(\n  str: Path,\n  options?: ParseOptions & TokensToRegexpOptions & RegexpToFunctionOptions,\n) {\n  const keys: Key[] = [];\n  const re = pathToRegexp(str, keys, options);\n  return regexpToFunction<P>(re, keys, options);\n}\n\n/**\n * Create a path match function from `path-to-regexp` output.\n */\nexport function regexpToFunction<P extends object = object>(\n  re: RegExp,\n  keys: Key[],\n  options: RegexpToFunctionOptions = {},\n): MatchFunction<P> {\n  const { decode = (x: string) => x } = options;\n\n  return function (pathname: string) {\n    const m = re.exec(pathname);\n    if (!m) return false;\n\n    const { 0: path, index } = m;\n    const params = Object.create(null);\n\n    for (let i = 1; i < m.length; i++) {\n      if (m[i] === undefined) continue;\n\n      const key = keys[i - 1];\n\n      if (key.modifier === \"*\" || key.modifier === \"+\") {\n        params[key.name] = m[i].split(key.prefix + key.suffix).map((value) => {\n          return decode(value, key);\n        });\n      } else {\n        params[key.name] = decode(m[i], key);\n      }\n    }\n\n    return { path, index, params };\n  };\n}\n\n/**\n * Escape a regular expression string.\n */\nfunction escapeString(str: string) {\n  return str.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, \"\\\\$1\");\n}\n\n/**\n * Get the flags for a regexp from the options.\n */\nfunction flags(options?: { sensitive?: boolean }) {\n  return options && options.sensitive ? \"\" : \"i\";\n}\n\n/**\n * Metadata about a key.\n */\nexport interface Key {\n  name: string | number;\n  prefix: string;\n  suffix: string;\n  pattern: string;\n  modifier: string;\n}\n\n/**\n * A token is a string (nothing special) or key metadata (capture group).\n */\nexport type Token = string | Key;\n\n/**\n * Pull out keys from a regexp.\n */\nfunction regexpToRegexp(path: RegExp, keys?: Key[]): RegExp {\n  if (!keys) return path;\n\n  const groupsRegex = /\\((?:\\?<(.*?)>)?(?!\\?)/g;\n\n  let index = 0;\n  let execResult = groupsRegex.exec(path.source);\n  while (execResult) {\n    keys.push({\n      // Use parenthesized substring match if available, index otherwise\n      name: execResult[1] || index++,\n      prefix: \"\",\n      suffix: \"\",\n      modifier: \"\",\n      pattern: \"\",\n    });\n    execResult = groupsRegex.exec(path.source);\n  }\n\n  return path;\n}\n\n/**\n * Transform an array into a regexp.\n */\nfunction arrayToRegexp(\n  paths: Array<string | RegExp>,\n  keys?: Key[],\n  options?: TokensToRegexpOptions & ParseOptions,\n): RegExp {\n  const parts = paths.map((path) => pathToRegexp(path, keys, options).source);\n  return new RegExp(`(?:${parts.join(\"|\")})`, flags(options));\n}\n\n/**\n * Create a path regexp from string input.\n */\nfunction stringToRegexp(\n  path: string,\n  keys?: Key[],\n  options?: TokensToRegexpOptions & ParseOptions,\n) {\n  return tokensToRegexp(parse(path, options), keys, options);\n}\n\nexport interface TokensToRegexpOptions {\n  /**\n   * When `true` the regexp will be case sensitive. (default: `false`)\n   */\n  sensitive?: boolean;\n  /**\n   * When `true` the regexp won't allow an optional trailing delimiter to match. (default: `false`)\n   */\n  strict?: boolean;\n  /**\n   * When `true` the regexp will match to the end of the string. (default: `true`)\n   */\n  end?: boolean;\n  /**\n   * When `true` the regexp will match from the beginning of the string. (default: `true`)\n   */\n  start?: boolean;\n  /**\n   * Sets the final character for non-ending optimistic matches. (default: `/`)\n   */\n  delimiter?: string;\n  /**\n   * List of characters that can also be \"end\" characters.\n   */\n  endsWith?: string;\n  /**\n   * Encode path tokens for use in the `RegExp`.\n   */\n  encode?: (value: string) => string;\n}\n\n/**\n * Expose a function for taking tokens and returning a RegExp.\n */\nexport function tokensToRegexp(\n  tokens: Token[],\n  keys?: Key[],\n  options: TokensToRegexpOptions = {},\n) {\n  const {\n    strict = false,\n    start = true,\n    end = true,\n    encode = (x: string) => x,\n    delimiter = \"/#?\",\n    endsWith = \"\",\n  } = options;\n  const endsWithRe = `[${escapeString(endsWith)}]|$`;\n  const delimiterRe = `[${escapeString(delimiter)}]`;\n  let route = start ? \"^\" : \"\";\n\n  // Iterate over the tokens and create our regexp string.\n  for (const token of tokens) {\n    if (typeof token === \"string\") {\n      route += escapeString(encode(token));\n    } else {\n      const prefix = escapeString(encode(token.prefix));\n      const suffix = escapeString(encode(token.suffix));\n\n      if (token.pattern) {\n        if (keys) keys.push(token);\n\n        if (prefix || suffix) {\n          if (token.modifier === \"+\" || token.modifier === \"*\") {\n            const mod = token.modifier === \"*\" ? \"?\" : \"\";\n            route += `(?:${prefix}((?:${token.pattern})(?:${suffix}${prefix}(?:${token.pattern}))*)${suffix})${mod}`;\n          } else {\n            route += `(?:${prefix}(${token.pattern})${suffix})${token.modifier}`;\n          }\n        } else {\n          if (token.modifier === \"+\" || token.modifier === \"*\") {\n            throw new TypeError(\n              `Can not repeat \"${token.name}\" without a prefix and suffix`,\n            );\n          }\n\n          route += `(${token.pattern})${token.modifier}`;\n        }\n      } else {\n        route += `(?:${prefix}${suffix})${token.modifier}`;\n      }\n    }\n  }\n\n  if (end) {\n    if (!strict) route += `${delimiterRe}?`;\n\n    route += !options.endsWith ? \"$\" : `(?=${endsWithRe})`;\n  } else {\n    const endToken = tokens[tokens.length - 1];\n    const isEndDelimited =\n      typeof endToken === \"string\"\n        ? delimiterRe.indexOf(endToken[endToken.length - 1]) > -1\n        : endToken === undefined;\n\n    if (!strict) {\n      route += `(?:${delimiterRe}(?=${endsWithRe}))?`;\n    }\n\n    if (!isEndDelimited) {\n      route += `(?=${delimiterRe}|${endsWithRe})`;\n    }\n  }\n\n  return new RegExp(route, flags(options));\n}\n\n/**\n * Supported `path-to-regexp` input types.\n */\nexport type Path = string | RegExp | Array<string | RegExp>;\n\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n */\nexport function pathToRegexp(\n  path: Path,\n  keys?: Key[],\n  options?: TokensToRegexpOptions & ParseOptions,\n) {\n  if (path instanceof RegExp) return regexpToRegexp(path, keys);\n  if (Array.isArray(path)) return arrayToRegexp(path, keys, options);\n  return stringToRegexp(path, keys, options);\n}\n","import { compile, pathToRegexp } from 'path-to-regexp';\n\nclass RouteCompiler {\n  /**\n   * A cache for storing compiled path generators to optimize performance.\n   */\n  static compileCache = {};\n  /**\n   * Finds the first route from a list of routes that matches the given path.\n   *\n   * @param routes An array of route objects containing `realpath` props.\n   * @param path The actual path to match against the route patterns.\n   *\n   * @returns The first matching route object, or `null` if no match is found.\n   */\n  static pick(routes, path) {\n    const [pathname] = path.split(\"?\");\n    return routes.find((obj) => this.test(obj.realpath, pathname)) || null;\n  }\n  /**\n   * Compiles a route pattern into a reusable function for generating paths.\n   *\n   * @param route The route pattern to compile (e.g., `/users/:id`).\n   * @param encodeURI Whether to encode URI components (default: `true`).\n   *\n   * @returns A function that generates a URL path given the required parameters.\n   */\n  static compile(route, encodeURI = true) {\n    const cached = this.compileCache[route];\n    if (cached) {\n      return cached;\n    }\n    const generator = compile(\n      this.normalize(route),\n      encodeURI ? { encode: encodeURIComponent } : {}\n    );\n    return this.compileCache[route] = (data) => {\n      try {\n        return generator(data);\n      } catch (e) {\n        throw new TypeError(\n          `Error generating a path for route \"${route}\" with params \"${JSON.stringify(data)}\": ${e.message}`\n        );\n      }\n    };\n  }\n  /**\n   * Tests if a given path matches a specified route pattern.\n   *\n   * @param route The route pattern to match against (e.g., `/users/:id`).\n   * @param path The actual path to check (e.g., `/users/123`).\n   *\n   * @returns `true` if the path matches the route pattern, otherwise `false`.\n   */\n  static test(route, path) {\n    const regexp = pathToRegexp(this.normalize(route));\n    return regexp.test(path);\n  }\n  /**\n   * Normalizes a route path by removing trailing slashes.\n   *\n   * Ensures that:\n   * - Routes can match paths with or without a trailing slash.\n   * - All generated paths maintain a consistent format.\n   *\n   * @param route The route to normalize.\n   *\n   * @returns The normalized route string without trailing slashes.\n   */\n  static normalize(route) {\n    return route.replace(/^(.+?)\\/*?$/, \"$1\");\n  }\n}\n\nexport { RouteCompiler as R };\n","function r(e){var t,f,n=\"\";if(\"string\"==typeof e||\"number\"==typeof e)n+=e;else if(\"object\"==typeof e)if(Array.isArray(e)){var o=e.length;for(t=0;t<o;t++)e[t]&&(f=r(e[t]))&&(n&&(n+=\" \"),n+=f)}else for(f in e)e[f]&&(n&&(n+=\" \"),n+=f);return n}export function clsx(){for(var e,t,f=0,n=\"\",o=arguments.length;f<o;f++)(e=arguments[f])&&(t=r(e))&&(n&&(n+=\" \"),n+=t);return n}export default clsx;","import { navigate as navigate$1, withPrefix, Link as Link$1 } from 'gatsby';\nimport { useLocation } from '@reach/router';\nimport { R as RouteCompiler } from './route-compiler-DlYb6nBY.js';\nimport routes from 'gatsby-plugin-advanced-pages-cache/routes.json';\nimport { jsx } from 'react/jsx-runtime';\nimport { Component } from 'react';\nimport { clsx } from 'clsx';\nimport 'path-to-regexp';\n\nlet cachedRoutes = null;\nconst getRoutes = (parent) => {\n  if (!cachedRoutes) {\n    cachedRoutes = [];\n    for (const { name, path, scopes } of routes) {\n      cachedRoutes.push({\n        name,\n        path,\n        realpath: withPrefix(path),\n        parent: null\n      });\n      Object.entries(scopes).forEach(([scope, scopePath]) => {\n        cachedRoutes.push({\n          name: `${name}.${scope}`,\n          path: scopePath,\n          realpath: withPrefix(scopePath),\n          parent: { name, scope }\n        });\n      });\n    }\n  }\n  return parent ? cachedRoutes.filter((r) => r.parent?.name === parent) : cachedRoutes;\n};\nconst getRoute = (route) => {\n  if (typeof route !== \"string\" || !route) {\n    throw new TypeError(`Expected route name to be a non-empty string (got '${typeof route}')`);\n  }\n  const ro = getRoutes().find((r) => r.name === route);\n  if (!ro) {\n    throw new TypeError(`Unrecognized route name '${route}'`);\n  }\n  return ro;\n};\nconst routeExists = (route) => {\n  return getRoutes().some((r) => r.name === route);\n};\nconst getMatchingRoute = (path, ignorePrefix = false) => {\n  return RouteCompiler.pick(getRoutes(), ignorePrefix ? path : withPrefix(path));\n};\nconst getPathGenerator = (route, scope, ignorePrefix = false) => {\n  const ro = getRoute(route);\n  if (!scope) {\n    return RouteCompiler.compile(ignorePrefix ? ro.path : ro.realpath);\n  }\n  const childRo = getRoutes(route).find((r) => r.parent?.scope === scope);\n  if (!childRo) {\n    throw new TypeError(`Unrecognized scope '${scope}' on route '${route}'`);\n  }\n  return RouteCompiler.compile(ignorePrefix ? childRo.path : childRo.realpath);\n};\nconst generatePath = (route, params = {}, scope, ignorePrefix = false) => {\n  return getPathGenerator(route, scope, ignorePrefix)(params);\n};\nconst navigate = (to, params = {}, scope, options) => navigate$1(generatePath(to, params, scope), options);\nconst useRoute = () => {\n  const { pathname } = useLocation();\n  return getMatchingRoute(pathname, true);\n};\nconst useIsRoute = (route) => {\n  const current = useRoute();\n  const ro = getRoute(route);\n  return current ? Boolean(ro.name === current.name || current.parent && current.parent.name === ro.name) : false;\n};\n\nconst Link = ({ to, params, scope, ...props }) => {\n  if (to != null && routeExists(to)) {\n    try {\n      to = generatePath(to, params, scope, true);\n    } catch (e) {\n      if (process.env.NODE_ENV !== \"production\") {\n        console.error(\n          `gatsby-plugin-advanced-pages: Unable to generate path for route \"${to}\": ${e.message}`\n        );\n      }\n      to = \"/404.html\";\n    }\n  }\n  return /* @__PURE__ */ jsx(Link$1, { to, ...props });\n};\n\nclass Pagination extends Component {\n  static defaultProps = {\n    ui: \"full\",\n    range: 6,\n    labels: {\n      first: \"\\xAB First\",\n      prev: \"\\u2190 Previous\",\n      next: \"Next \\u2192\",\n      last: \"Last \\xBB\"\n    },\n    theme: {\n      inner: \"pagination\",\n      item: \"page-item\",\n      \"item.next\": \"page-item__next\",\n      \"item.prev\": \"page-item__prev\",\n      \"item.first\": \"page-item__first\",\n      \"item.last\": \"page-item__last\",\n      link: \"page-link\",\n      active: \"active\",\n      disabled: \"disabled\"\n    },\n    renderDisabled: true\n  };\n  render() {\n    const props = {\n      ...Pagination.defaultProps,\n      ...this.props,\n      labels: {\n        ...Pagination.defaultProps.labels,\n        ...this.props.labels\n      },\n      theme: {\n        ...Pagination.defaultProps.theme,\n        ...this.props.theme\n      }\n    };\n    const {\n      ui,\n      labels,\n      theme,\n      pageInfo: { pageCount, currentPage, hasNextPage, hasPreviousPage }\n    } = props;\n    const pages = [];\n    if (ui === \"full\") {\n      pages.push({\n        key: \"first\",\n        number: 1,\n        type: \"first\",\n        label: labels.first,\n        disabled: !hasPreviousPage\n      });\n    }\n    pages.push({\n      key: \"prev\",\n      number: currentPage - 1,\n      type: \"prev\",\n      label: labels.prev,\n      disabled: !hasPreviousPage\n    });\n    if (ui !== \"mini\") {\n      const [fp, lp] = this.calcRange(pageCount, currentPage, props.range);\n      for (let i = fp; i <= lp; i++) {\n        pages.push({\n          key: i,\n          number: i,\n          type: \"page\",\n          label: i.toString(),\n          active: i === currentPage\n        });\n      }\n    }\n    pages.push({\n      key: \"next\",\n      number: currentPage + 1,\n      type: \"next\",\n      label: labels.next,\n      disabled: !hasNextPage\n    });\n    if (ui === \"full\") {\n      pages.push({\n        key: \"last\",\n        number: pageCount,\n        type: \"last\",\n        label: labels.last,\n        disabled: !hasNextPage\n      });\n    }\n    return /* @__PURE__ */ jsx(\"nav\", { className: props.className, role: \"navigation\", \"aria-label\": \"Pagination Navigation\", children: /* @__PURE__ */ jsx(\"ul\", { className: theme.inner, children: pages.map((page) => {\n      if (page.disabled && !props.renderDisabled) {\n        return null;\n      }\n      const classes = [theme.item];\n      const typeClass = theme[\"item.\" + page.type];\n      if (typeClass) {\n        classes.push(typeClass);\n      }\n      classes.push({\n        [theme.active]: page.active,\n        [theme.disabled]: page.disabled\n      });\n      if (page.disabled) {\n        return /* @__PURE__ */ jsx(\"li\", { className: clsx(classes), children: /* @__PURE__ */ jsx(\"a\", { className: theme.link, children: page.label }) }, page.key);\n      }\n      const [params, scope] = page.number === 1 ? [props.params, null] : [{ ...props.params, page: page.number }, \"pagination\"];\n      return /* @__PURE__ */ jsx(\"li\", { className: clsx(classes), children: /* @__PURE__ */ jsx(Link, { to: props.route, params, scope, className: theme.link, children: page.label }) }, page.key);\n    }) }) });\n  }\n  calcRange(pageCount, currentPage, range) {\n    const halfRange = Math.floor(range / 2);\n    let firstPage = Math.max(1, currentPage - halfRange);\n    let lastPage = Math.min(pageCount, currentPage + halfRange);\n    const currentRange = lastPage - firstPage + 1;\n    if (currentRange < range) {\n      const adjustment = range - currentRange;\n      if (currentPage < pageCount / 2) {\n        lastPage = Math.min(pageCount, lastPage + adjustment);\n      } else {\n        firstPage = Math.max(1, firstPage - adjustment);\n      }\n    }\n    if (lastPage - firstPage + 1 > range) {\n      currentPage > pageCount / 2 ? firstPage++ : lastPage--;\n    }\n    return [firstPage, lastPage];\n  }\n}\n\nexport { Link, Pagination, generatePath, getMatchingRoute, getPathGenerator, getRoute, getRoutes, navigate, routeExists, useIsRoute, useRoute };\n","function _objectWithoutPropertiesLoose(r, e) {\n  if (null == r) return {};\n  var t = {};\n  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {\n    if (-1 !== e.indexOf(n)) continue;\n    t[n] = r[n];\n  }\n  return t;\n}\nexport { _objectWithoutPropertiesLoose as default };"],"names":["menu","title","route","_ref","children","React","className","Link","to","map","link","key","activeClassName","partiallyActive","Date","getFullYear","href","parse","str","options","tokens","i","length","char","push","type","index","value","count","pattern","j","TypeError","concat","name","code","charCodeAt","lexer","_a","prefixes","_b","delimiter","result","path","tryConsume","mustConsume","undefined","nextType","consumeText","safePattern","prefix","prev","prevText","_i","delimiter_1","indexOf","isSafe","escapeString","suffix","modifier","name_1","pattern_1","compile","reFlags","flags","encode","x","validate","matches","token","RegExp","data","optional","repeat","Array","isArray","segment","test","typeOfMessage","String","tokensToFunction","replace","sensitive","stringToRegexp","keys","strict","start","_c","end","_d","_e","_f","endsWith","endsWithRe","delimiterRe","tokens_1","mod","endToken","isEndDelimited","tokensToRegexp","pathToRegexp","groupsRegex","execResult","exec","source","regexpToRegexp","paths","parts","join","arrayToRegexp","RouteCompiler","pick","routes","pathname","split","find","obj","this","realpath","encodeURI","cached","compileCache","generator","normalize","encodeURIComponent","e","JSON","stringify","message","r","t","f","n","o","clsx","arguments","cachedRoutes","getRoutes","parent","scopes","withPrefix","Object","entries","forEach","scope","scopePath","filter","_r$parent","getRoute","ro","generatePath","params","ignorePrefix","childRo","_r$parent2","getPathGenerator","_ref2","props","hasOwnProperty","call","_objectWithoutPropertiesLoose","_excluded","some","process","jsx","Link$1","assign","Pagination","_Component","apply","_inheritsLoose","_proto","prototype","render","defaultProps","labels","theme","ui","pageInfo","pageCount","currentPage","hasNextPage","hasPreviousPage","pages","number","label","first","disabled","fp","lp","calcRange","range","toString","active","next","last","role","inner","page","renderDisabled","classes","item","typeClass","halfRange","Math","floor","firstPage","max","lastPage","min","currentRange","adjustment","Component"],"sourceRoot":""}